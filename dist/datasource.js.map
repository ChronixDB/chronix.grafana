{"version":3,"sources":["../src/datasource.js"],"names":["escapeTag","name","indexOf","toTagQueryString","tag","tagName","map","join","toTargetQueryString","target","tags","Object","keys","length","targetQueryStrings","_","toTargetJoinString","attributes","requiredFields","ChronixDbDatasource","instanceSettings","$q","backendSrv","templateSrv","type","url","options","start","range","from","unix","end","to","targets","rawQuery","then","extractTimeSeries","method","successMessage","status","message","title","errorMessage","reject","datasourceRequest","response","success","catch","tsName","emptyResult","when","data","facet_counts","facet_fields","nameFields","console","log","filter","unused","index","text","targetsQueryStrings","query","joinquery","RAW_QUERY_BASE","RAW_QUERY_JOIN","RAW_QUERY_FILTER_FUNCTION","RAW_QUERY_BASE_WITH_FILTER","targetsResponse","undefined","dataset","docs","tsPoints","i","currentDataSet","currentTimeSeries","jsonData","JSON","parse","dataAsJson","timestamps","values","j","push","ret","key","datapoints","mapToTextValue","result","fields","stringFields","property","hasOwnProperty","toLowerCase","attribute","mapValueToText","field","pairs","pair","value"],"mappings":"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","file":"datasource.js","sourcesContent":["import _ from 'lodash';\n\nfunction escapeTag(name) {\n    return name.indexOf('.') !== -1 ? `\"${name}\"` : name;\n}\n\nfunction toTagQueryString(tag, tagName) {\n    return tagName + ':(' + tag.map(escapeTag).join(' OR ') + ')'\n}\n\nfunction toTargetQueryString(target) {\n    if (!target.tags || Object.keys(target.tags).length === 0) {\n        // simple name-only\n        return target.name;\n    }\n\n    // create strings for each tag\n    const targetQueryStrings = _(target.tags).map(toTagQueryString);\n\n    return '(' + target.name + ' AND ' + targetQueryStrings.join(' AND ') + ')';\n}\n\nfunction toTargetJoinString(target) {\n    if (!target.attributes || Object.keys(target.attributes).length === 0) {\n        return \"name\";\n    }\n    // create strings for each tag\n    return _(target.attributes).join(',') + \",name,type\";\n}\n\nvar requiredFields = [\"data\", \"start\", \"end\", \"_version_\", \"id\", \"name\", \"type\"];\n\nexport class ChronixDbDatasource {\n\n    constructor(instanceSettings, $q, backendSrv, templateSrv) {\n        this.type = instanceSettings.type;\n        this.url = instanceSettings.url;\n        this.name = instanceSettings.name;\n        this.$q = $q;\n        this.backendSrv = backendSrv;\n        this.templateSrv = templateSrv;\n    }\n\n    //region Required Grafana Datasource methods\n\n    query(options) {\n        // get the start and the end and multiply it with 1000 to get millis since 1970\n        var start = options.range.from.unix() * 1000;\n        var end = options.range.to.unix() * 1000;\n        var targets = options.targets;\n\n        return this.rawQuery(targets, start, end).then(this.extractTimeSeries);\n    }\n\n    /**\n     * Attempts to connect to the URL entered by the user and responds with a promise to either a \"success\" or an\n     * \"error\" message.\n     */\n    testDatasource() {\n        const options = {\n            url: `${this.url}/select?q=%7B!lucene%7D*%3A*&rows=0`,\n            method: 'GET'\n        };\n        const successMessage = {\n            status: \"success\",\n            message: \"Connection to Chronix established\",\n            title: \"Success\"\n        };\n        const errorMessage = this.$q.reject({\n            status: \"error\",\n            message: \"Connection to Chronix failed\",\n            title: \"Error\"\n        });\n\n        // perform the actual call...\n        return this.backendSrv.datasourceRequest(options)\n        // ... check if the response is technically successful ...\n            .then(response => response && response.status === 200)\n            // ... and respond appropriately\n            .then(success => success ? successMessage : errorMessage)\n            // ... and react appropriately, too, when the call somehow didn't work\n            .catch(error => errorMessage);\n    }\n\n    /**\n     *\n     */\n    findTimeSeriesByNames(tsName) {\n        const emptyResult = this.$q.when([]);\n\n        if (!tsName || tsName === '*') {\n            // no \"*\" accepted from the user\n            return emptyResult;\n        }\n\n        if (tsName.indexOf('*') === -1) {\n            // append an \"*\" at the end if the user didn't already provide one\n            tsName = tsName + '*';\n        }\n\n        const options = {\n            //do a facet query\n            url: `${this.url}/select?facet.field=name&facet=on&facet.mincount=1&q=name:${tsName}&rows=0&wt=json`,\n            method: 'GET'\n        };\n\n        return this.backendSrv.datasourceRequest(options)\n            .then(response => response && response.data && response.data.facet_counts && response.data.facet_counts.facet_fields && response.data.facet_counts.facet_fields.name)\n            .then((nameFields) => {\n                // somehow no valid response => empty array\n                if (!nameFields) {\n                    console.log(`could not find any matching time series for \"${tsName}\"`);\n                    return emptyResult;\n                }\n\n                // take only the names, not the counts\n                return nameFields\n                    .filter((unused, index) => index % 2 === 0)\n                    // and provide them as objects with the \"text\" property\n                    .map(text => ({text}));\n            })\n            // if the request itself failed\n            .catch(error => emptyResult);\n    }\n\n    //endregion\n\n    rawQuery(targets, start, end) {\n        // create strings for each target\n        var targetsQueryStrings = _(targets).map(toTargetQueryString);\n\n        var query = 'name:(' + targetsQueryStrings.join(' OR ') + ')'\n            + ' AND start:' + start\n            + ' AND end:' + end;\n\n        var joinquery = _(targets).map(toTargetJoinString);\n\n        //At this point we have to query chronix\n        var RAW_QUERY_BASE = '/select?fl=dataAsJson&wt=json';\n        var RAW_QUERY_JOIN = '&cj=' + joinquery;\n        var RAW_QUERY_FILTER_FUNCTION = '';//'&cf=metric{vector:0.1}';\n        var RAW_QUERY_BASE_WITH_FILTER = RAW_QUERY_BASE + RAW_QUERY_FILTER_FUNCTION + RAW_QUERY_JOIN + '&q=';\n\n        console.log(\"Chronix Query: \" + RAW_QUERY_BASE_WITH_FILTER + query);\n\n        var options = {\n            method: 'GET',\n            url: this.url + RAW_QUERY_BASE_WITH_FILTER + query\n        };\n\n        return this.backendSrv.datasourceRequest(options).then(function (response) {\n            return [targets, response];\n        });\n    }\n\n    extractTimeSeries(targetsResponse) {\n        var response = targetsResponse[1];\n\n        if (response.data === undefined) {\n            return {data: []};\n        }\n        var dataset = response.data.response.docs;\n\n        var tsPoints = {};\n\n        for (var i = 0; i < dataset.length; i++) {\n            var currentDataSet = dataset[i];\n            var currentTimeSeries = currentDataSet.name;\n\n            if (!(currentTimeSeries in tsPoints)) {\n                tsPoints[currentTimeSeries] = [];\n            }\n\n            var jsonData = JSON.parse(currentDataSet.dataAsJson);\n\n            var timestamps = jsonData[0];\n            var values = jsonData[1];\n\n            //add them\n            for (var j = 0; j < timestamps.length; j++) {\n                tsPoints[currentTimeSeries].push([values[j], timestamps[j]]);\n            }\n\n        }\n\n        var ret = [];\n        for (var key in tsPoints) {\n            ret.push({target: key, datapoints: tsPoints[key]});\n        }\n        return {data: ret};\n    }\n\n    /**\n     * Gets the available fields / attributes\n     */\n    suggestAttributes() {\n        var options = {\n            method: 'GET',\n            url: this.url + '/admin/luke?numTerms=0&wt=json'\n        };\n\n        return this.backendSrv.datasourceRequest(options).then(this.mapToTextValue);\n    }\n\n    mapToTextValue(result) {\n        var fields = result.data.fields;\n\n        var stringFields = [];\n        //Iterate over the returned fields\n        for (var property in fields) {\n            if (fields.hasOwnProperty(property)) {\n                if (requiredFields.indexOf(property.toLowerCase()) == -1) {\n                    stringFields.push(property)\n                }\n            }\n        }\n        return _.map(stringFields, (name) => {\n            return {text: name};\n        });\n    }\n\n    /**\n     * Gets the available values for the attributes.\n     *\n     * @param name The name to get the available attributes.\n     * @param attribute The attribute.\n     */\n    suggestAttributesValues(name, attribute) {\n        var options = {\n            method: 'GET',\n            url: this.url + '/select?facet.field=' + attribute + '&facet=on&q=name:' + name + '&rows=0&wt=json'\n        };\n\n        return this.backendSrv.datasourceRequest(options).then(this.mapValueToText);\n    }\n\n    mapValueToText(result) {\n        var fields = result.data.facet_counts.facet_fields;\n\n        var field;\n        //Iterate over the returned fields\n        for (var property in fields) {\n            if (fields.hasOwnProperty(property)) {\n                field = property;\n            }\n        }\n\n        var pairs = [];\n        var values = fields[field];\n\n        //Build pairs\n        for (var i = 0; i < values.length; i++) {\n            pairs.push([values[i], values[++i]]);\n        }\n\n        return _.map(pairs, (pair) => {\n            return {text: pair[0], value: pair[1]};\n        });\n    }\n\n}\n"]}