{"version":3,"sources":["../src/datasource.js"],"names":["escapeTag","metric","indexOf","toTagQueryString","tag","tagName","map","join","toTargetQueryString","target","tags","Object","keys","length","targetQueryStrings","_","toTargetJoinString","attributes","requiredFields","ChronixDbDatasource","instanceSettings","$q","backendSrv","templateSrv","type","url","name","options","start","range","from","unix","end","to","targets","rawQuery","then","extractTimeSeries","method","successMessage","status","message","title","errorMessage","reject","datasourceRequest","response","success","catch","emptyResult","when","data","facet_counts","facet_fields","metricFields","console","log","filter","unused","index","text","targetsQueryStrings","query","joinquery","RAW_QUERY_BASE","RAW_QUERY_JOIN","RAW_QUERY_FILTER_FUNCTION","RAW_QUERY_BASE_WITH_FILTER","targetsResponse","undefined","dataset","docs","tsPoints","i","currentDataSet","currentMetric","jsonData","JSON","parse","dataAsJson","timestamps","values","j","push","ret","key","datapoints","mapToTextValue","result","fields","stringFields","property","hasOwnProperty","toLowerCase","attribute","mapValueToText","field","pairs","pair","value"],"mappings":"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","file":"datasource.js","sourcesContent":["import _ from 'lodash';\r\n\r\nfunction escapeTag (metric) {\r\n    return metric.indexOf('.') !== -1 ? `\"${metric}\"` : metric;\r\n}\r\n\r\nfunction toTagQueryString (tag, tagName) {\r\n    return tagName + ':(' + tag.map(escapeTag).join(' OR ') + ')'\r\n}\r\n\r\nfunction toTargetQueryString (target) {\r\n    if (!target.tags || Object.keys(target.tags).length === 0) {\r\n        // simple metric-only\r\n        return target.metric;\r\n    }\r\n\r\n    // create strings for each tag\r\n    const targetQueryStrings = _(target.tags).map(toTagQueryString);\r\n\r\n    return '(' + target.metric + ' AND ' + targetQueryStrings.join(' AND ') + ')';\r\n}\r\n\r\nfunction toTargetJoinString (target) {\r\n    if (!target.attributes || Object.keys(target.attributes).length === 0) {\r\n        return \"metric\";\r\n    }\r\n    // create strings for each tag\r\n    return _(target.attributes).join(',') + \",metric\";\r\n}\r\n\r\nvar requiredFields = [\"data\", \"start\", \"end\", \"_version_\", \"id\", \"metric\"];\r\n\r\nexport class ChronixDbDatasource {\r\n\r\n    constructor (instanceSettings, $q, backendSrv, templateSrv) {\r\n        this.type = instanceSettings.type;\r\n        this.url = instanceSettings.url;\r\n        this.name = instanceSettings.name;\r\n        this.$q = $q;\r\n        this.backendSrv = backendSrv;\r\n        this.templateSrv = templateSrv;\r\n    }\r\n\r\n    //region Required Grafana Datasource methods\r\n\r\n    query (options) {\r\n        // get the start and the end and multiply it with 1000 to get millis since 1970\r\n        var start = options.range.from.unix() * 1000;\r\n        var end = options.range.to.unix() * 1000;\r\n        var targets = options.targets;\r\n\r\n        return this.rawQuery(targets, start, end).then(this.extractTimeSeries);\r\n    }\r\n\r\n    /**\r\n     * Attempts to connect to the URL entered by the user and responds with a promise to either a \"success\" or an\r\n     * \"error\" message.\r\n     */\r\n    testDatasource () {\r\n        const options = {\r\n            url: `${this.url}/select?q=%7B!lucene%7D*%3A*&rows=0`,\r\n            method: 'GET'\r\n        };\r\n        const successMessage = {\r\n            status: \"success\",\r\n            message: \"Connection to ChronixDB established\",\r\n            title: \"Success\"\r\n        };\r\n        const errorMessage = this.$q.reject({\r\n            status: \"error\",\r\n            message: \"Connection to ChronixDB failed\",\r\n            title: \"Error\"\r\n        });\r\n\r\n        // perform the actual call...\r\n        return this.backendSrv.datasourceRequest(options)\r\n            // ... check if the response is technically successful ...\r\n            .then(response => response && response.status === 200)\r\n            // ... and respond appropriately\r\n            .then(success => success ? successMessage : errorMessage)\r\n            // ... and react appropriately, too, when the call somehow didn't work\r\n            .catch(error => errorMessage);\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    metricFindQuery (metric) {\r\n        const emptyResult = this.$q.when([]);\r\n\r\n        if (!metric || metric === '*') {\r\n            // no \"*\" accepted from the user\r\n            return emptyResult;\r\n        }\r\n\r\n        if (metric.indexOf('*') === -1) {\r\n            // append an \"*\" at the end if the user didn't already provide one\r\n            metric = metric + '*';\r\n        }\r\n\r\n        const options = {\r\n            //do a facet query\r\n            url: `${this.url}/select?facet.field=metric&facet=on&facet.mincount=1&q=metric:${metric}&rows=0&wt=json`,\r\n            method: 'GET'\r\n        };\r\n\r\n        return this.backendSrv.datasourceRequest(options)\r\n            .then(response => response && response.data && response.data.facet_counts && response.data.facet_counts.facet_fields && response.data.facet_counts.facet_fields.metric)\r\n            .then((metricFields) => {\r\n                // somehow no valid response => empty array\r\n                if (!metricFields) {\r\n                    console.log(`could not find any metrics matching \"${metric}\"`);\r\n                    return emptyResult;\r\n                }\r\n\r\n                // take only the metric names, not the counts\r\n                return metricFields\r\n                    .filter((unused, index) => index % 2 === 0)\r\n                    // and provide them as objects with the \"text\" property\r\n                    .map(text => ({text}));\r\n            })\r\n            // if the request itself failed\r\n            .catch(error => emptyResult);\r\n    }\r\n\r\n    //endregion\r\n\r\n    rawQuery (targets, start, end) {\r\n        // create strings for each target\r\n        var targetsQueryStrings = _(targets).map(toTargetQueryString);\r\n\r\n        var query = 'metric:(' + targetsQueryStrings.join(' OR ') + ')'\r\n            + ' AND start:' + start\r\n            + ' AND end:' + end;\r\n\r\n        var joinquery = _(targets).map(toTargetJoinString);\r\n\r\n        //At this point we have to query chronix\r\n        var RAW_QUERY_BASE = '/select?fl=dataAsJson&wt=json';\r\n        var RAW_QUERY_JOIN = '&fq=join=' + joinquery;\r\n        var RAW_QUERY_FILTER_FUNCTION = '';//'&fq=function=vector:0.1';\r\n        var RAW_QUERY_BASE_WITH_FILTER = RAW_QUERY_BASE + RAW_QUERY_FILTER_FUNCTION + RAW_QUERY_JOIN + '&q=';\r\n\r\n        console.log(\"ChronixDB Query: \" + RAW_QUERY_BASE_WITH_FILTER + query);\r\n\r\n        var options = {\r\n            method: 'GET',\r\n            url: this.url + RAW_QUERY_BASE_WITH_FILTER + query\r\n        };\r\n\r\n        return this.backendSrv.datasourceRequest(options).then(function (response) {\r\n            return [targets, response];\r\n        });\r\n    }\r\n\r\n    extractTimeSeries (targetsResponse) {\r\n        var response = targetsResponse[1];\r\n\r\n        if (response.data === undefined) {\r\n            return {data: []};\r\n        }\r\n        var dataset = response.data.response.docs;\r\n\r\n        var tsPoints = {};\r\n\r\n        for (var i = 0; i < dataset.length; i++) {\r\n            var currentDataSet = dataset[i];\r\n            var currentMetric = currentDataSet.metric;\r\n\r\n            if (!(currentMetric in tsPoints)) {\r\n                tsPoints[currentMetric] = [];\r\n            }\r\n\r\n            var jsonData = JSON.parse(currentDataSet.dataAsJson);\r\n\r\n            var timestamps = jsonData[0];\r\n            var values = jsonData[1];\r\n\r\n            //add them\r\n            for (var j = 0; j < timestamps.length; j++) {\r\n                tsPoints[currentMetric].push([values[j], timestamps[j]]);\r\n            }\r\n\r\n        }\r\n\r\n        var ret = [];\r\n        for (var key in tsPoints) {\r\n            ret.push({target: key, datapoints: tsPoints[key]});\r\n        }\r\n        return {data: ret};\r\n    }\r\n\r\n    /**\r\n     * Gets the available fields / attributes\r\n     */\r\n    suggestAttributes () {\r\n        var options = {\r\n            method: 'GET',\r\n            url: this.url + '/admin/luke?numTerms=0&wt=json'\r\n        };\r\n\r\n        return this.backendSrv.datasourceRequest(options).then(this.mapToTextValue);\r\n    }\r\n\r\n    mapToTextValue (result) {\r\n        var fields = result.data.fields;\r\n\r\n        var stringFields = [];\r\n        //Iterate over the returned fields\r\n        for (var property in fields) {\r\n            if (fields.hasOwnProperty(property)) {\r\n                if (requiredFields.indexOf(property.toLowerCase()) == -1) {\r\n                    stringFields.push(property)\r\n                }\r\n            }\r\n        }\r\n        return _.map(stringFields, (name) => {\r\n            return {text: name};\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the available values for the attributes.\r\n     *\r\n     * @param metric The metric to get the available attributes.\r\n     * @param attribute The attribute.\r\n     */\r\n    suggestAttributesValues (metric, attribute) {\r\n        var options = {\r\n            method: 'GET',\r\n            url: this.url + '/select?facet.field=' + attribute + '&facet=on&q=metric:' + metric + '&rows=0&wt=json'\r\n        };\r\n\r\n        return this.backendSrv.datasourceRequest(options).then(this.mapValueToText);\r\n    }\r\n\r\n    mapValueToText (result) {\r\n        var fields = result.data.facet_counts.facet_fields;\r\n\r\n        var field;\r\n        //Iterate over the returned fields\r\n        for (var property in fields) {\r\n            if (fields.hasOwnProperty(property)) {\r\n                field = property;\r\n            }\r\n        }\r\n\r\n        var pairs = [];\r\n        var values = fields[field];\r\n\r\n        //Build pairs\r\n        for (var i = 0; i < values.length; i++) {\r\n            pairs.push([values[i], values[++i]]);\r\n        }\r\n\r\n        return _.map(pairs, (pair) => {\r\n            return {text: pair[0], value: pair[1]};\r\n        });\r\n    }\r\n\r\n}\r\n"]}